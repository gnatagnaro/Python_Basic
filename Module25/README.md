## Практическая работа
## Цели практической работы
- Отработать применение принципа инкапсуляции в Python:
  - защита атрибутов класса от случайных внешних изменений, создание приватных атрибутов и методов класса;
  - сеттеры и геттеры.
- Отработать применение принципа наследования в Python:
  - создание нового класса на основе уже существующего, рассмотрение понятия базового (родительского) и дочернего класса;
  - дополнение дочернего класса новыми атрибутами, функция super.
- Отработать применение принципа полиморфизма в Python: изменение функционала, который наследуется от базового класса.
- Отработать написание документации для классов и методов, улучшить стиль программирования.
## Что входит в работу
- Задача 1. Налоги.
- Задача 2. Карма.
- Задача 3. Свой словарь.
- Задача 4. RPG-игра.
- Задача 5. Стек.
- 
## Задача 1. Налоги
### Что нужно сделать
Реализуйте иерархию классов, описывающих имущество налогоплательщиков. Она должна состоять из базового класса `Property` и производных от него классов `Apartment`, `Car` и `CountryHouse`. 

Базовый класс должен иметь атрибут worth (стоимость), который передаётся в конструктор, и метод расчёта налога, переопределённый в каждом из производных классов. Налог на квартиру вычисляется как 1/1000 её стоимости, на машину — 1/200, на дачу — 1/500. 

Каждый дочерний класс должен иметь конструктор с одним параметром, передающий свой параметр конструктору базового класса.

Разработайте интерфейс программы. Пусть она запрашивает у пользователя количество его денег и стоимость имущества, а затем выдаёт налог на соответствующее имущество и показывает, сколько денег ему не хватает (если это так).
### Что оценивается
- Результат вычислений корректен.
- `input` содержит корректные приглашения для ввода. 
- Модели реализованы в стиле ООП, основной функционал описан в методах классов и в отдельных функциях.
- При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
  - Для получения и установки значений у приватных атрибутов используются сеттеры и геттеры.
  - Для создания нового класса на основе уже существующего используется наследование.
- Сообщения о процессе получения результата осмыслены и понятны для пользователя.
- Переменные, функции и собственные методы классов имеют значащие имена, а не `a`, `b`, `c`, `d`.
- Классы и методы/функции имеют прописанную документацию.

## Задача 2. Карма
### Что нужно сделать
Один буддист-программист решил создать свой симулятор жизни, в котором нужно набрать 500 очков кармы (это константа), чтобы достичь просветления. 

Каждый день вызывается специальная функция `one_day()`, которая возвращает количество кармы от 1 до 7 и может с вероятностью 1 к 10 выкинуть одно из исключений:

- `KillError`;
- `DrunkError`;
- `CarCrashError`;
- `GluttonyError`;
- `DepressionError`.

Напишите такую программу. Функцию оберните в бесконечный цикл, выход из которого возможен только при накоплении кармы до уровня константы. Исключения обработайте и запишите в отдельный лог `karma.log`.
### Что оценивается
- Результат вычислений корректен.
- Модели реализованы в стиле ООП, основной функционал описан в методах классов и в отдельных функциях.
- При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
  - Для получения и установки значений у приватных атрибутов используются сеттеры и геттеры.
  - Для создания нового класса на основе уже существующего используется наследование.
- Сообщения о процессе получения результата осмыслены и понятны для пользователя.
- Переменные, функции и собственные методы классов имеют значащие имена, а не `a`, `b`, `c`, `d`.
- Классы и методы/функции имеют прописанную документацию.
- Названия используемых файлов соответствуют тем, которые написаны в задаче.

## Задача 3. Свой словарь
### Что нужно сделать
В силу обстоятельств Васе постоянно приходится работать со словарями и их данными. В том числе и с методом `get`, который по умолчанию возвращает `None`, если такого ключа в словаре нет. Однако Васю это не устраивает: для нормальной работы ему нужно возвращать число 0.

Реализуйте класс `MyDict`, который будет вести себя точно так же, как и обычный словарь, за исключением того, что метод `get` по умолчанию будет возвращать не `None`, а число 0.

### Что оценивается
- Результат вычислений корректен.
- Модели реализованы в стиле ООП, основной функционал описан в методах классов и в отдельных функциях.
- Сообщения о процессе получения результата осмыслены и понятны для пользователя.
- Переменные, функции и собственные методы классов имеют значащие имена, а не `a`, `b`, `c`, `d`.
- Классы и методы/функции имеют прописанную документацию.

## Задача 4. RPG игра

Вася решил заняться разработкой компьютерных игр (кстати python применяется даже в геймдеве!).
Ему поручили разрабатывать искусственный интеллект для союзников, которые сражаются бок о бок с реальными игроками.
Но так как Вася пока не силён в теме машинного обучения и нейросетей - ему предстоит заменить эти знания смекалкой и набором if/else 
условий.

Вася уже написал код, описывающий монстров (файл monsters.py), этот код изменять нельзя.
В файле heroes.py вы найдете заготовки системы классов: 
 -- базовый класс Hero, который нельзя изменять
 -- наследники класса Tank/Healer/Attacker - их надо изменять

Помимо этого в main.py есть код который:
1) запускает 1 год сражений - изменять нельзя
2) создает команду для сражения с монстрами - изменять можно, но с условиями
3) запускает 20 раз 1 год сражений и подсчитывает количество побед - изменять нельзя

Ваша задача:
1) Дописать код в классы Tank/Healer/Attacker в файле heroes.py
2) Сформировать команду в main.py
3) Проверить, что с выбранной вами стратегией герои побеждают монстров как минимум в половине случаев (>=10 побед из 20)

Цель:
Из 20 сражений нужно побеждать как минимум в 10 (в сражениях много случайностей, поэтому убедитесь в нескольких разных запусках ваша 
команда набирает нужное количество очков).

Советы и рекомендации:
- Внимательно изучите код поведения монстров (изменять его нельзя, но изучать не запрещено)
- При помощи команды принт выводите информацию о том кто и что делает в каждый день (особое внимание уделите информации, которая идёт в 
  последние дни перед поражением героев)
- На основе полученной информации попробуйте изменять приоритеты действий (обратите внимание, что вы можете не только выбирать действие 
  для выполнения, но также выбрать цель для действия. Иногда может быть выгоднее атаковать монстров конкретного класса, чтобы уменьшить 
  урон по вашей команде.)
  

## Задача 5. Стек
### Что нужно сделать
Мы уже говорили, что в программировании нередко необходимо создавать свои собственные структуры данных на основе уже существующих. Одной из таких «базовых» структур является стек. 

Стек — это абстрактный тип данных, представляющий собой список элементов, организованных по принципу `LIFO` (англ. last in — first out, «последним пришёл — первым вышел»).

Простой пример: стек из книг на столе. Единственной книгой, чья обложка видна, является самая верхняя. Чтобы получить доступ к, например, третьей снизу книге, нам нужно убрать все книги, лежащие сверху, одну за другой.

Напишите класс, который реализует стек и его возможности (достаточно будет добавления и удаления элемента). 

После этого напишите ещё один класс — «Менеджер задач». В менеджере задач можно выполнить команду «новая задача», в которую передаётся сама задача (`str`) и её приоритет (`int`). Сам менеджер работает на основе стека (не наследование!). При выводе менеджера в консоль все задачи должны быть отсортированы по приоритету: чем меньше число, тем выше задача.

Вот пример основной программы:
```
manager = TaskManager()
manager.new_task("сделать уборку", 4)
manager.new_task("помыть посуду", 4)
manager.new_task("отдохнуть", 1)
manager.new_task("поесть", 2)
manager.new_task("сдать дз", 2)
print(manager)

Результат:
1 отдохнуть
2 поесть; сдать дз
4 сделать уборку; помыть посуду
```

Дополнительно: реализуйте также удаление задач и подумайте, что делать с дубликатами.
### Что оценивается
- Результат вычислений корректен.
- Модели реализованы в стиле ООП, основной функционал описан в методах классов и в отдельных функциях.
- При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
  - Для получения и установки значений у приватных атрибутов используются сеттеры и геттеры.
  - Для создания нового класса на основе уже существующего используется наследование.
- Формат вывода соответствует примеру.
- Переменные, функции и собственные методы классов имеют значащие имена, а не `a`, `b`, `c`, `d`.
- Классы и методы/функции имеют прописанную документацию.

## Что оценивается в практической работе
- Задание сдано через GitLab.
- Структура папок и файлов репозитория соответствует репозиторию python_basic.
- Все задачи выполнены в соответствующих папках и файлах main.py.
- Описания коммитов осмыслены и понятны: `111`, `done`, `«я сделалъ»` — неверно; `added m15 homework`, `14.3 fix: variables naming` — верно.
- Использованы именованные индексы, а не просто `i` (подробнее в видео 7.2).
- Использованы правильные числа, без дополнительных действий со стороны пользователя, без `+1` (подробнее об этом в видео 7.4).
- Правильно оформлен `input`, без пустого приветствия для ввода (подробнее об этом в видео 2.3).
- Переменные и функции имеют значащие имена, а не только `a`, `b`, `c`, `d` (подробнее об этом в видео 2.3).
- Присутствуют пробелы после запятых и при бинарных операциях.
- Отсутствуют пробелы после имён функций и перед скобками: `print ()`, `input ()` — неверно; `print()` — верно.
- Правильно оформлены блоки `if-elif-else`, циклы и функции, отступы одинаковы во всех блоках одного уровня.
- Все входные и выходные файлы называются так, как указано в заданиях.
- Работа с файлами осуществляется с помощью контекстного менеджера `with`.
- Для обработки исключений используются блоки `try-except`.
- Модели реализованы в стиле ООП, основной функционал описан в методах классов и в отдельных функциях.
- При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
  - Для получения и установки значений у приватных атрибутов используются сеттеры и геттеры.
  - Для создания нового класса на основе уже существующего используется наследование.
- Если классы вынесены в отдельный модуль, то импортируются определённые классы (запись вида `from garden import *` считается плохим тоном).
- Классы и методы/функции имеют прописанную документацию.
## Советы и рекомендации
- Арифметические операции [PEP8](https://docs.python.org/3.7/reference/expressions.html#operator-precedence) остаются в приоритете. Необходимо вводить and, or.
- Руководство по стилю Python [PEP8](https://www.python.org/dev/peps/pep-0008/) на английском языке.
- Руководство по стилю Python [PEP8](https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html) на русском языке.
- [Список встроенных функций](https://docs.python.org/3.7/library/functions.html).

## Как отправить работу на проверку
Чтобы выполнить практическую работу, обновите репозиторий python_basic на своём компьютере при помощи IDE PyCharm. Задачи находятся в папке Module25.

Сдайте практические работы этого модуля через систему контроля версий Git сервиса Skillbox Gitlab. В материалах с практической работой напишите «Сделано» и прикрепите ссылку на репозиторий. Ссылки на реплит оставлять не нужно.

